{
  parserClass="io.github.anonymous123_code.chasmlang.parser.ChassemblyParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Chassembly"
  psiImplClassSuffix="Impl"
  psiPackage="io.github.anonymous123_code.chasmlang.psi"
  psiImplPackage="io.github.anonymous123_code.chasmlang.psi.impl"

  elementTypeHolderClass="io.github.anonymous123_code.chasmlang.psi.ChassemblyTypes"
  elementTypeClass="io.github.anonymous123_code.chasmlang.psi.ChassemblyElementType"
  tokenTypeClass="io.github.anonymous123_code.chasmlang.psi.ChassemblyTokenType"

  psiImplUtilClass="io.github.anonymous123_code.chasmlang.psi.extend.ChassemblyPsiImplUtil"

  tokens = [
    PLUS_OPERATOR = "+"
    MINUS_OPERATOR = "-"
    NOT_OPERATOR = "!"
    INVERT_OPERATOR = "~"
    MULTIPLY_OPERATOR = "*"
    DIVIDE_OPERATOR = "/"
    MODULO_OPERATOR = "%"
    SHIFT_LEFT_OPERATOR = "<<"
    SHIFT_RIGHT_OPERATOR = ">>"
    SHIFT_RIGHT_UNSIGNED_OPERATOR = ">>>"
    LESS_THAN_OPERATOR = "<"
    LESS_THAN_OR_EQUAL_OPERATOR = "<="
    GREATER_THAN_OPERATOR = ">"
    GREATER_THAN_OR_EQUAL_OPERATOR = ">="
    EQUAL_OPERATOR = "="
    NOT_EQUAL_OPERATOR = "!="
    BITWISE_AND_OPERATOR = "&"
    BITWISE_XOR_OPERATOR = "^"
    BITWISE_OR_OPERATOR = "|"
    BOOLEAN_AND_OPERATOR = "&&"
    BOOLEAN_OR_OPERATOR = "||"
    TERNARY_OPERATOR = "?"
    LAMBDA_OPERATOR = "->"

    COMMA = ","
    DOT = "."
    COLON = ":"
    LEFT_PARANTHESES = "("
    RIGHT_PARANTHESES = ")"
    LEFT_BRACKETS = "["
    RIGHT_BRACKETS = "]"
    LEFT_BRACES = "{"
    RIGHT_BRACES = "}"

    LINE_COMMENT = "regexp://([^\n])*"
    BLOCK_COMMENT = "regexp:/[*]([^*]|([*][^/]))*[*]/"

    NULL_LITERAL = "null"
    BOOLEAN_LITERAL = "regexp:(true|false)"
    DEC_INTEGER_LITERAL = "regexp:[+-]?[0-9]+"
    HEX_INTEGER_LITERAL = "regexp:[+-]?0x[0-9a-fA-F]+"
    BIN_INTGER_LITERAL = "regexp:[+-]?0b[01]+"
    FLOAT_LITERAL = "regexp:[+-]?(NaN|Infinity|((([0-9]+\.[0-9]*)|(\.[0-9]+))([eE][+-]?[0-9]+)?))"
    STRING_LITERAL = "regexp:\"([^\"\\]|(\\\")|(\\\\))*\""
    CHAR_LITERAL = "regexp:'([^'\\]|(\\')|(\\\\))'"
    REFERENCE_LITERAL = "regexp:`([^`\\]|(\\`)|(\\\\))*`"

    IDENTIFIER = "regexp:[_a-zA-Z][_a-zA-Z0-9]*"
  ]
}

chassemblyFile ::= expression

expression ::= (lambdaExpression | ternaryExpression) {methods=[getType]}

lambdaExpression ::= IDENTIFIER LAMBDA_OPERATOR expression {methods=[getType]}
ternaryExpression ::= booleanOrExpression (TERNARY_OPERATOR ternaryExpression COLON ternaryExpression)? {methods=[getType]}

booleanOrExpression ::= booleanAndExpression (BOOLEAN_OR_OPERATOR booleanAndExpression)* {methods=[getType]}
booleanAndExpression ::= bitwiseOrExpression (BOOLEAN_AND_OPERATOR bitwiseOrExpression)* {methods=[getType]}

bitwiseOrExpression ::= bitwiseXorExpression (BITWISE_OR_OPERATOR bitwiseXorExpression)* {methods=[getType]}
bitwiseXorExpression ::= bitwiseAndExpression (BITWISE_XOR_OPERATOR bitwiseAndExpression)* {methods=[getType]}
bitwiseAndExpression ::= equalityExpression (BITWISE_AND_OPERATOR equalityExpression)* {methods=[getType]}

equalityExpression ::= relationalExpression ((EQUAL_OPERATOR | NOT_EQUAL_OPERATOR) relationalExpression)* {methods=[getType]}
relationalExpression ::= shiftExpression ((LESS_THAN_OPERATOR | LESS_THAN_OR_EQUAL_OPERATOR | GREATER_THAN_OPERATOR | GREATER_THAN_OR_EQUAL_OPERATOR) shiftExpression)* {methods=[getType]}

shiftExpression ::= additiveExpression ((SHIFT_LEFT_OPERATOR | SHIFT_RIGHT_OPERATOR | SHIFT_RIGHT_UNSIGNED_OPERATOR) additiveExpression)* {methods=[getType]}

additiveExpression ::= multiplicativeExpression (addition | subtraction)* {methods=[getType]}
left addition ::= PLUS_OPERATOR multiplicativeExpression {methods=[getType]}
left subtraction ::= MINUS_OPERATOR multiplicativeExpression {methods=[getType]}
multiplicativeExpression ::= unaryExpression ((MULTIPLY_OPERATOR | DIVIDE_OPERATOR | MODULO_OPERATOR) unaryExpression)* {methods=[getType]}

unaryExpression ::= numberReturningUnary | booleanReturningUnary | integerReturningUnary {methods=[getType]}

booleanReturningUnary ::= NOT_OPERATOR argumentExpression {methods=[getType]}
numberReturningUnary ::= (PLUS_OPERATOR | MINUS_OPERATOR)? argumentExpression {methods=[getType]}
integerReturningUnary ::= INVERT_OPERATOR argumentExpression {methods=[getType]}

argumentExpression ::= primaryExpression (call | arrayAccess | propertyAccess)* {methods=[getType]}

left call ::= LEFT_PARANTHESES callParam RIGHT_PARANTHESES {methods=[getType]}
private callParam ::= expression { recoverWhile = callParamRecovery}
private callParamRecovery ::= !(RIGHT_PARANTHESES)

left arrayAccess ::= LEFT_BRACKETS arrayAccessParam RIGHT_BRACKETS {methods=[getType]}
private arrayAccessParam ::= expression {recoverWhile = arrayAccessParamRecovery}
private arrayAccessParamRecovery ::= !(RIGHT_BRACKETS)

left propertyAccess ::= DOT (IDENTIFIER | REFERENCE_LITERAL) {methods=[getType]}

primaryExpression ::= literalExpression | referenceExpression | parenthesesExpression | listExpression | mapExpression {methods=[getType]}

literalExpression ::= (NULL_LITERAL | BOOLEAN_LITERAL | DEC_INTEGER_LITERAL | HEX_INTEGER_LITERAL | BIN_INTGER_LITERAL | FLOAT_LITERAL | STRING_LITERAL | CHAR_LITERAL)

referenceExpression ::= ("$")? (IDENTIFIER | REFERENCE_LITERAL)

parenthesesExpression ::= (LEFT_PARANTHESES parenthesesInnerExpression RIGHT_PARANTHESES)
private parenthesesInnerExpression ::= expression { recoverWhile=parenthesesInnerExpressionRecovery }
private parenthesesInnerExpressionRecovery ::= !(RIGHT_PARANTHESES)

listExpression ::= LEFT_BRACKETS listExpressionElements? RIGHT_BRACKETS
private listExpressionElements ::= listExpressionElementsElement (COMMA listExpressionElementsElement)*  (COMMA)? { recoverWhile=listExpressionElementsRecovery }
private listExpressionElementsRecovery ::= !(RIGHT_BRACKETS)
private listExpressionElementsElement ::= expression { recoverWhile=listExpressionElementsElementRecovery }
private listExpressionElementsElementRecovery ::= !(COMMA | RIGHT_BRACKETS)

mapExpression ::= mapExpressionEmpty | mapExpressionFull
private mapExpressionEmpty ::= LEFT_BRACES RIGHT_BRACES { pin = 2 }
private mapExpressionFull ::= LEFT_BRACES mapExpressionElements RIGHT_BRACES { pin = 2 }
private mapExpressionElements ::= mapKeyValuePair (COMMA mapKeyValuePair)* (COMMA)? { recoverWhile=mapExpressionElementsRecovery }
private mapExpressionElementsRecovery ::= !(RIGHT_BRACES)

mapKeyValuePair ::= mapKey COLON mapValue { recoverWhile=mapKeyValuePairRecovery pin=1 }
private mapKeyValuePairRecovery ::= !(RIGHT_BRACES | COMMA)

mapKey ::= (IDENTIFIER | STRING_LITERAL) { recoverWhile=mapKeyRecovery }
private mapKeyRecovery ::= !(RIGHT_BRACES | COMMA | COLON)

mapValue ::= expression { recoverWhile=mapValueRecovery methods=[getType]}
private mapValueRecovery ::= !(RIGHT_BRACES | COMMA)

// List, map, call, map access need recover

commentToken ::= LINE_COMMENT | BLOCK_COMMENT